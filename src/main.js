
/*jshint esversion: 6 */
const https = require('https');
const express = require("express");
const bodyParser = require("body-parser");
const url = require("url");
const fs = require("fs");
const sentiment = require('sentiment');
const databox = require('node-databox');

//My https certs generated by the container manager
const credentials = databox.getHttpsCredentials();

//The endpoint for my datastore (Where i can publish my sentiment data)
const DATABOX_ZMQ_ENDPOINT = process.env.DATABOX_ZMQ_ENDPOINT

//connect to my store to write data
let sentimentStore = new databox.NewTimeSeriesBlobClient(DATABOX_ZMQ_ENDPOINT, false)
sentimentStore.RegisterDatasource({
        Description: 'Twitter user timeline sentiment',
        ContentType: 'text/json',
        Vendor: 'Databox Inc.',
        DataSourceType: 'twitter:sentiment:UserTimeline',
        DataSourceID: 'UserTimelineSentiment',
        StoreType: 'tsblob',
})
.then(()=>{
    sentimentStore.RegisterDatasource({
        Description: 'Twitter hash tag sentiment',
        ContentType: 'text/json',
        Vendor: 'Databox Inc.',
        DataSourceType: 'twitter:sentiment:HashTag',
        DataSourceID: 'HashTagSentiment',
        StoreType: 'tsblob',
    })
})
.catch((err)=>{
    console.log("RegisterDatasource Error:: " + err)
})

//The endpoint for the data sources requested in the manifest ( env var name derived from the id in the manifest)
let twitterUserTimeLine = {};
let testActuator = {};
let twitterHashTagStream = {};

databox.HypercatToSourceDataMetadata(process.env.DATASOURCE_DS_twitterHashTagStream)
.then((data)=>{
    twitterHashTagStream = data
    return Promise.resolve(new databox.NewTimeSeriesBlobClient(twitterHashTagStream.DataSourceURL, false))
})
.then((twitterStore) => {
    console.log("subscribing")
    return twitterStore.Observe(twitterHashTagStream.DataSourceMetadata.DataSourceID)
    .then((emitter)=>{
        console.log("subscribing to data source 1 " + twitterHashTagStream.DataSourceMetadata.DataSourceID + " got emitter");
        emitter.on('data',(data)=>{
            let tweet = JSON.parse(data.data);
            latestTweet = { tweet:tweet.text, sentiment:sentiment(tweet.text) };
            sentimentData = { location: tweet.user.location, sentiment: sentiment(tweet.text) };
            console.log("twitterHashTagStream received ")
            databox.export.longpoll('https://export.amar.io/', sentimentData)
                .catch((err)=>{
                    console.log("ERROR databox.export.longpoll " + err);
                });
                sentimentStore.Write('HashTagSentiment',sentimentData)
                .catch((err)=>{
                    console.warn(err);
                });
        });
        emitter.on('error',(err)=>{
            console.warn(err);
        });
        return
    })
    .catch((err)=>{
        console.log("subscribing to twitterUserTimeLine Error:: " + err)
    })
})
.catch((err)=>{
    console.log("subscribing to twitterHashTagStream Error:: " + err)
})

databox.HypercatToSourceDataMetadata(process.env.DATASOURCE_DS_twitterUserTimeLine)
.then((data)=>{
    twitterUserTimeLine = data
    return Promise.resolve(new databox.NewTimeSeriesBlobClient(twitterUserTimeLine.DataSourceURL, false))
})
.then((twitterStore) => {
    console.log("subscribing")
    return twitterStore.Observe(twitterUserTimeLine.DataSourceMetadata.DataSourceID)
    .then((emitter)=>{
        console.log("subscribing to data source 2 " + twitterUserTimeLine.DataSourceMetadata.DataSourceID + " got emitter");
        emitter.on('data',(data)=>{
            let tweet = JSON.parse(data.data);
            latestTweet = { tweet:tweet.text, sentiment:sentiment(tweet.text) };
            sentimentData = { location: tweet.user.location, sentiment: sentiment(tweet.text) };
            console.log("twitterUserTimeLine received ")
            databox.export.longpoll('https://export.amar.io/', sentimentData)
            .catch((err)=>{
                console.log("ERROR databox.export.longpoll " + err);
            });
            sentimentStore.Write('UserTimelineSentiment',sentimentData)
            .catch((err)=>{
                console.warn(err);
            });
        });
        emitter.on('error',(err)=>{
            console.warn(err);
        });
        return
    })
    .catch((err)=>{
        console.log("subscribing to twitterUserTimeLine Error:: " + err)
    })
})
.catch((err)=>{
    console.log("subscribing to twitterUserTimeLine Error:: " + err)
})

//Express server for UI
console.log("stating ui server");
let app = express();

let status = "init";
app.get("/status", function(req, res) {
    res.send(status);
});

let latestTweet = {tweet:"No tweets received yet ...."};
app.get("/ui", function(req, res) {
    res.send("<html><script>setTimeout(function(){window.location.reload();},2000);</script><body><h2><pre>" + JSON.stringify(latestTweet, null, 4) + "</pre></h2></body></html>");
});

app.get("/ui/acctest", function(req, res) {
    console.log("GOT REQUEST to /ui/acctest");
    twitterStore.Write(testActuator.DataSourceMetadata.DataSourceID,{'test':'ing 123'})
    .then((body)=>{
        res.send("<h2>OK > " + body + "</h2>");
    })
    .catch((error)=>{
        res.send("<h2>ERROR::" + error + "</h2>");
    });
});

//start the express server
https.createServer(credentials, app).listen(8080);

module.exports = app;
